

1) Location: Alcanza location siendo un string?
Location: Alcanza location siendo un string?
[
    {
    "id": "9a15c50f-c056-4023-90f1-2a94e863e977
    "title": "Concierto de Jazz",
    "description": "Noche de jazz en vivo",
    "location": "Teatro Colón",
    "startDateTime": "2025-09-10T20:00:00",
    "durationMinutes": 120,
    "maxParticipants": 200,
    "price": 1500
    }
]

NO RESUELTO

--> Que la location sea un string provee mas flexibilidad a la hora de que el usuario
introduzca la ubicacion pero tiene la desventaja que puede no ser facilmente ubicable
si es un nombre generico. Seria util ponerle Latitud/Longitud u otro sistema de ubicación
complementario que de la ubicación exacta.



2) El organizerId iría en el body del evento?
POST /events
Content-Type: application/json
{
"title": "Concierto de Jazz",
"description": "Noche de jazz en vivo",
"location": "Teatro Colón",
"startDateTime": "2025-09-10T20:00:00",
"durationMinutes": 120,
"maxParticipants": 200,
"price": 1500,
"organizerId": "fcf41137-d0ef-434d-a170-8bb815b67809"
}

NO RESUELTO

--> Si sacamos el endpoint de post de eventos en /eventos y lo pasamos a /accounts/{id}/eventos
dejaria de hacer falta. Aun así hay que dejar el get de /eventos para obtener eventos de cualquiera
O tal vez se refiere a identificar el organizador mediante el token de seguridad?
Podria ir en un header el userID y el token?
Probablemente la segunda opcion sea la mejor, ya hablan de las url en otro punto


3) Pensaron en ponerle password?

EN PROCESO

--> Le estamos poniendo password en la branch de login. Una vez terminado hay que propagar
el login al frontend

4) Qué pasa si este GET me devuelve un millón de eventos?
   GET /events?titleContains=Jazz&minPrice=1000&maxPrice=2000

SOLUCIONADO ¿?

--> Le pusimos paginacion con ?page=xyz&limit=xyz, pero no pusimos nigun limite al tamaño
de página y los parametros son opcionales. Hay que considerar establecer un maximo
en el "limit" y que siempre este paginado, en caso de que alguien comience a consumir la api
sin páginas


5) Endpoints a revisar - REST: Que otra forma se les ocurre de diseñarlo? Cumplen con las convenciones REST?
POST /accounts/{accountId}/organized-events/{eventId}/close
GET /accounts/{accountId}/organized-events/{eventId}/participants
GET /accounts/{accountId}/organized-events/{eventId}/waitlist
POST /events/registration

EN PROCESO

POST /accounts/{accountId}/organized-events/{eventId}/close
--> Quedo obsoleto con PATCH /accounts/{accountId}/organized-events/{eventId}

GET /accounts/{accountId}/organized-events/{eventId}/participants
GET /accounts/{accountId}/organized-events/{eventId}/waitlist
--> No estoy seguro aun del error, pero es posible que se trate de unificarlo en un ...{eventId}/registrations con queryParams?
    También puede ser que se refiera a un /events/{id}/registrations, ya que el {accountId} no
    es necesario para ver la lista de participantes

POST /events/registration
--> Se debe modificar para que sea post a events/{id}/registrations (o /registrations?)


6) Me interesa saber qué user organiza el evento? Se plantearon esto cuando lo discutieron?

NO RESUELTO
--> No lo discutimos. Dimos por hecho que era información util.
    Puede ser mejor ocultarlo para mantener la privacidad del organizador, o mostrarlo para que haya mas transparencia


7) Según cómo plantearon la solución ustedes. Si se filtra el accountId del organizador, estaría en peligro la seguridad de mi API?

EN PROCESO

--> Una vez implementemos el sistema de login con tokens, se debera enviar el token cada vez que se realice una peticion, por lo que no se pondra en peligro nuestra API si se filtra el accountId.

8) Errores y validaciones
   Catchear un NullPointerException para validar mi request huele feo :( . Hay una mejor práctica para hacer esto.
   Manejar casos de uso devolviendo strings y después mapeándolos tampoco es buena práctica:
   "ORGANIZER_CANNOT_REGISTER";
   "ALREADY_REGISTERED";
   "ALREADY_IN_WAITLIST";

NO RESUELTO

--> Para la NullPointerException, debemos crear una excepcion nuestra, que atrape la NullPointer en capa service (o repository) y
    que lanze la nuestra propia
--> Hay que crear objetos de respuesta para los registros:
    --> Registro exitoso: Devolver el registro
    --> Registro fallido: No hay que hacer un switch para ver que pasa. Hay que poner excepciones personalizadas para cada caso de error y atraparlas en el controller

9) Qué pasa si alguien que está en una lista de espera se quiere bajar del evento?

NO RESUELTO

--> Esta mal hecha la logica. Intenta siempre eliminar de participantes y siempre promueve a uno de la WAITLIST.
--> Hay que chequear el estado del registro primero

10) (En cancelRegistration) Si un user está intentando acceder a algo que no debería, retorno booleano? mmm eso esta raro.

NO RESUELTO

--> En   @DeleteMapping("/{registrationId}")
    registrationService.cancelRegistration(registrationId, accountId); devuelve un booleano
    Hay que hacer que siempre devuelva void y tire exception si falla, la cual se atrape en el controller

11) Concurrencia
    Qué pasa si empiezo a tener concurrencia en el proceso de (cancelación + promoción de waitlist)? La operación es atómica como está hecho ahora?

NO RESUELTO

--> Si hay concurrencia, puede que se introduzca la misma persona de la waitlist 2 veces en la lista de participantes.
    Hay que resolverlo con campos atomicos o MUTEX (investigar)

///////////////////////////////////////////////

Consulta seguridad por telegram

Cuando uno arranca una conversación con un bot desde una cuenta de telegram, te asigna un
userID.  Dependiendo de cómo esté configurada la cuenta de telegram, podrías acceder
al nombre y alias si es que lo tiene generado, para customizar un poco la interacción con
ese usuario guest.

Ahora, si tienen pensado tener una UI front, con un sign up user y pass, podrían tener
una opción para generar un one time password (OTP) para loggearte en el bot. Un session
ticket para poder loggearte y poder identificar el usuario detrás. Tengan en cuenta
que esos OTP tienen que caducar en pocos minutos, y poder usarse una única vez.

Con eso evitarían tener que introducir la contraseña en mensajes planos. Si están encarando
primero el bot, pueden arrancar con la contraseña en texto, y luego ver de resolver esto una
vez que tengan el front donde estar loggeado.

NO RESUELTO

--> Esperando a que termine de desarrollarse el login
